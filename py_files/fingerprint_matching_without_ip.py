# -*- coding: utf-8 -*-
"""Fingerprint_Matching_without_IP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YXZtMyBI7qQbispgcf5SvW_Q43J6nMc2

```
Author ===> Yagnik Poshiya
GitHub ===> @yagnikposhiya
Charotar University Of Science and Technology, CSPIT,
Anand, Gujarat, India.
```

## **GPU Version: Google Colab**
"""

!nvidia-smi --query-gpu=gpu_name,driver_version,memory.total --format=csv

"""## **0. Libraries**"""

# Libraries for phase 1
import os
import cv2

# Libraries for phase 2
import numpy as np # 2.1, 2.2
from sklearn.model_selection import train_test_split # 2.1
from tensorflow.keras.utils import to_categorical # 2.1, 2.2

# Libraries for phase 4
from keras.models import Sequential # 4.1
from keras import layers, regularizers, optimizers, callbacks # 4.1, 4.5
from tensorflow.keras.utils import plot_model # 4.3

# Library for phase 5
import tensorflow as tf

# Library for phase 6
import matplotlib.pyplot as plt

# Library for phase 7
import itertools
from sklearn.metrics import confusion_matrix

"""## **1. Loading Data**"""

image_size = 96 # for image resizing in (image_size, image_size) dimension

"""
      defining load_data function for loading data and generating 
      particular list of data/image for particular directory.

      Params:
      path => path of directory
      train => to differentiate training and testing category data/images
"""

def load_data(path, train=True):

  """
        training category image name:
              1__M_Left_index_finger_CR.BMP
        testing category image name:
              1__M_Left_index_finger.BMP
  """
  print('Loading data from: ', path) # printing path of directory
  data = [] # empty list to store data/image

  for image in os.listdir(path):

    """
          splitting image name into two sections:
          1. name of an image
          2. extension of an image
    """
    image_name, ext = os.path.splitext(image) 


    """
          splitting image name using double underscore (__):
          1. Subject ID number
          2. Training Images
                <GenderInformation>_<Hand>_<fingername>_<finger>_<TechniqueName>
          3. Testing Images
                <GenderInformation>_<Hand>_<fingername>_<finger>
    """
    ID, etc = image_name.split('__') 


    """
          subtracting 1 from every id number 
          to make list indexing process easy.
    """
    ID = int(ID) - 1 


    """
          splitting images information using single underscore(_)
          1. Training Images
              <GenderInformation>_<Hand>_<fingername>_<finger>_<TechniqueName>
                  a. _ (Underscore) = GenderInformation
                  b. lr (LeftRight) = Hand
                  c. finger = fingername
                  d. _ (Underscore) = finger (word)
                  e. _ (Underscore) = TechniqueName
          2. Testing Images
              <GenderInformation>_<Hand>_<fingername>_<finger>
                  a. _ (Underscore) = GenderInformation
                  b. lr (LeftRight) = Hand
                  c. finger = fingername
                  d. _ (Underscore) = finger (word)
    """
    if train:
      _, lr, finger, _, _ = etc.split('_')
    else:
      _, lr, finger, _ = etc.split('_')

    """
          Indexing Method:
          1. Left Hand         |  2. Right Hand
              a. little = 0    |      a. little = 5
              b. ring = 1      |      b. ring = 6
              c. middle = 2    |      c. middle = 7
              d. index = 3     |      d. index = 8
              e. thimb = 4     |      e. thumb = 9
    """
    if lr=='Left' :
      base = 0
    else: base = 5

    if finger=='little':
      fingerNum = base + 0
    elif finger=='ring':
      fingerNum = base + 1
    elif finger=='middle':
      fingerNum = base + 2
    elif finger=='index':
      fingerNum = base + 3
    else: fingerNum = base + 4

    image_array = cv2.imread(os.path.join(path, image), cv2.IMREAD_GRAYSCALE) # reading image in grayscale
    image_resize = cv2.resize(image_array,(image_size,image_size)) # resizing image in (96,96) dimension
    data.append([ID, fingerNum, image_resize]) # appending data/image into list

  return data # return list

"""### **1.1 Dataset Information**

![Dataset Information.png](data:image/png;base64,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16hRI/u7NqNXy5RHNokf8qkoFJWZ+FPVPv7rr79MV3Ts2NGtttpqiaX/gMb57LPP3L777ptYUjvIZrcKZ/hGjx7thg4d6n7++Wf33HPPueOPP9599dVX7tNPP3Wnn366++CDDxJbZubVV191H330UeJbZpZZZhm35557uqWXXjqxpCyLFi1yr7zyijvppJPc1VdfnRR+4h++/fZb89FOO+1kn1tuucX9+eefibWL159wwglut912c9tuu627+eabTUh7KEAvv/yya9++vW2z++672/dowcpnm7rEr7/+6i699FL7wJQpU8w2qZ8bbrjB1s+YMcMddthh5h98cN1119kxPF988YU79thjkz688sorrf55Un9P1DyzZs1yhxxyiHvppZfsO75OVwYoG7BgwQJ34YUXup133tm1adPG/mYZZCs/uY4rao5c9ZLEyTHHHJNsM4mXzzzzjPmPer7NNtu4O++8Mxmvc62HbOWorvLoo4+WqRu0UaNGjXJ///23+/HHH91xxx1XZv3BBx/s5s6da/vm6xPaPI7Ldk888USy7cu1vtoIf7AcGRaXIWyMgk8++cT+Hj58eNCiRYsgbLDs+7Bhw4IXX3zR/s5EaOCga9euObfz/PDDD0FopOCSSy5JLClLrvXFZuHChcH5558fdOvWLZg3b15iaXHJxw/5EBbaoFOnTsHAgQODUByb39q2bRuEIrnM+ltvvTUIC3/w5ZdfBmGhDK699lr7Dq+//nrQunXr4O2337bv48aNC5o0aWLLPflsU1mKZZOqZubMmUEYMOx8fZmkrJ944onB+PHjg2effdY+/fv3t/oTdpSCHXfcMRgwYID5aNq0aVanbr/9dtvX+4jtWU/5CwNUEDb0tj7d79UWaotPC+Gvv/4KHn/88aBp06Z2fT7OUQcHDx6c9P/YsWMtDhI7w45qcOaZZyZ9TFwhvrCMddnKT7bjxpHaHAeiUI9POumkMu3n1KlTg1133dX2Jf7ee++9Qb169YIJEybktT5XOaotFNvH1JP//Oc/yTrC54033jAboR+oL4899liZ9d9++63tm8vmtHG0dbR5QPwmnrMf5FpfTLLZrUIZPoZYN9lkE7fWWmsllpQFFbv22mu777//3noWqNkuXbq4559/njOxVOmBBx7oQqO5kSNHulBYWIaJdWzDtuxzyimn2PKKQM+aLCTHCIWMqfWw0Fsm8O6773b777+/fX/rrbcSeyzOoISVwn6b7aPZKbJd999/v2VgDj/8cHfuuee6Vq1auYMOOsgtu+yy7s0337TjsS/X7HsG9O6uv/76pA369u1b7b3uSZMmuQ8//NBS12RJV1llFcuY4iMIC7atpzdIOnjdddc1H4YNltmfa8dXW2+9tQsLre1DD4cyEFYQS43ns01dgQwzvbcw4JrfPeuvv74Lg77ba6+9XBg83HbbbWfLsfVrr71mWSB6f/iIaQlhQHBhw+3CgO1mz55tPtpwww1t/UorreQ22GAD65lm+j1RczDSEXacrO57qAPEPUYi8D8fysQWW2zhNt10Uxd2lCxm7bfffsl6uvfee7snn3zSffzxxxnLzy677JL1uKJmyFUvaVseeeQRazuikDVafvnlrQwQj4kFZOd8W5hrfa5yVJehbfJ1hA9tODaCFVdc0bVt27bM+gYNGti6XDb32dmGDRva/7StK6+8cnIEJtf66qJCgg+B06FDBzvhdGBUChkpUhr8p556yv5mOCpUxLaMSgAc5+ijj7b5fjRozM9DFJFq/emnn2zYuKJiIewJu7BXbL/H8BcirF+/fi7sddt3GlGGzTA6wuyyyy4zR3K+VJCwN2AOpWIOGzbMGt/bb7/dDRgwwE2ePNnNmTPHhmtorE899VR31llnWQXnfNmXYz799NPJCojwpPEmEFQXnAtD5/iEQsbvU2gvuugi17hxYzuXiRMnWkH0cy59gcZXn3zyiQlhxMh6663nVlhhBdsGwcE8SeyAn/LZpq5AYOjdu7fZMAq2iM5rff/99y2gYHs/NODLOsdgOcKBjhO+w18MI7z33nvu888/t3KHWMz0e6LmIOb06tXL6oBnqaWWMhG23HLL2XfiCnWPecms4+9VV121TBnZaKONrINMxzRT+aHOZTuuqBly1csXXnjBfNuzZ8/EksUwnYM2iM4dvpw2bZpr3bq123777fNan6sc1XVol+ko//3334kl/8Ay1rFNlFw2p31duHCh6QTaWNq8evXquc022yyv9dVFld2li1igh0uWYskllzQlTcZnxIgRNueOiwX+Z8IkIoQCivjDqIhKBCWijIxioRAcyYDQaPqsEw5CxfN3s2bN7Ny++eYbEz38HlmvHXbYwc4XwUpDO3/+fBMrCDd6yyyn98wxX3/9dRORZP7IdnIsBCZzDskkMqeRZWT0mOfINZJx9Jm16uCXX34xP9AbQZSS5UM4nHHGGSZ0+cycOdNs5YUaeP8waZU5JlwDNvXQkGBLBPEPP/yQ1zbiHxB248aNs/k1CGwCMjanESegIAAJEPzPttQROhSUVTI6ZKjJRtMjFbUT6gV1j3hEA8OoBHFk9dVXT2yxWDSss8461vGKklp+okSPK0oTxBcjIsRkfJwOkgfMu2buF9um+jPd+kLLUV2C9pekDtlwsp+04WPGjLF4S5tPW33ooYfaKB43nWJbNECUTD5B25DE4sbS5s2bu//+97+WTPKjoLnWVxdVJvgoWAg4f/cLgmqNNdZICqx0sJ5eKcMgOIShwOoCccLdOPSAGKalYHg4dxyDgKNCIUBpjBFuNMiIItazHZAKZhI1PW8EFiqeQkYvHOGHYKwuOFcvmrkmhm9vu+02K2wU9kzgi2xwrenubIqSzzZ1FTJ0DK8gvoHgQwZ80KBB7rzzzrMbn+hkRKHDwTAe5ZOyOHDgwDo/RFOboVNI3CAbkwk6vek6iKnlJ0o+xxU1B51s7g6lw+aHDNNBx44RKYRa9+7dyw395lofJVM5qksg5hhtI64yzemAAw4wEUa2jnbqgQcesCllrGeoneQN7bgfdYFMNkdMktQiaUQ2kBG9m266KTlkm2t9dVFlgo8LTJfZodB5YZQKQ4IMpaKaEXuIpOoCJd+1a1fLUt11113W6HoYljn77LOtYDB3jyFnn64nm8e10ksgvevH/skUkjGrX7++VW5SuBQwhqzvuOOOxJGrHs7Np459b2LLLbd0LVq0sGwSQhefMCQbTWMjYoHMH/vjE3qOHrZFdHBMepL5bCP+gR4iHQIviCljgwcPtqwNHQ/mgTKPlPXYlkwz5Y4yRvlhegFZ1csvv7zag4aoPPjsf//7n406kKEjJlJHiEN+/i8QP2mkoplzSC0/ntTjitKDudGMCpHdY27fNddcYwkSpj1xJ6kHkUYnD1FCDGAaEnHAk249yZRCylFdgraQ9tr/TTsdHeamTfd1hmF4hFnqdKRMPnnnnXdMCDJViuloTN8iNnOPAuRaX10URfCR7UqFGwAwFKIC+JthBhQyhkJo8D+NFhP+mWeG6sboNGpkzqKFm7H1qNJOhWPw8SDAsm2fCnOlUPcMkSDSGMf3cFwa2T59+phg49EvZMl8L5pJ1IjVGTNmJLd/6KGHTDTRU2CyLIWHzCXHiB67qkF0ItqwfTo/UYARg6ninG0ZLiRAcBMHc5J8hhPwD8PFpKexVz7biMXgf4YGKGvUA8BWBBfKU7t27ex/tmO+KY06nY13333X1hGUKE9kj6dOnWpD9qJ2QVykc+Tn8FAO6IjR8EfrIfWHbALrPOnKjyf1uKL0wG8+qUACgcQGU4+Y80mmn7YQIeHjqJ8LTRvKdKhs62kn8y1HdQn0AJk7PvwNTDfyIJCZn++HcBGE0fW5fEJ9JFYjBtmX2Ew2j2lf7JNrfXVRacGHoLniiiusgKFg+R/IcCGM6L1QsJkzhtg74ogjbD0XT0GnV8MwLobDAAw9MvTJHa8UUjIZ3LjBcZikft9995XpBQEBkOwHw6V+PcOVVCoMSuaECbKItkzfmTdIZoU5hMzvI3ByLahwRCmNKsNs3KHL8+rYh94BMBRHT415Vbvvvrt9mBNAgaACcoyTTz7ZnX/++fZ7zBGoLsgc8NwgrgdRC0waxd7YncKHH7A750ZlQGhzhzLniV0Y3uXmFAq9z/xxLG6ywZ/8Rj7b1DVSOyEehgHoHDBvz4PNmN9JGQfWMw8WmyLa6ZlSH77++mtbT2eGQEGng3mlkOn3RM2Bz1LBd2R5mNoRzXyTcUDIM+2CDgAfYhr1hzlFnnTlBzIdV9QsqfWSdsGPBNEmEoOpw2RlWceQPB+/D20PWSjKAB30XOvzLUd1CWyFJuDGCwQa7RyxFq2ByCYhwnMSmSoBJECwKcknOt+5bE6iiulqPknFdnz8iGau9dVGeOHlyLC4QoQXZc+4WbBgQWLJP/D8m7lz59o2njBA2rIweCWWVB/pzgdC0RaMGjUqCIWePe8qFLBBWFGDsHKWecYc18j+HCeVbOsyUSw/LEw8MzAMKMlzD8Vw8ly4vrAiBM2bNw/69OkTdO7c2bZnPw9+4Rlx/hihOA8efvhh29eTzzaVpZhlsyrB1zw3j/Nt3Lhx0Lt3b7MP8DwobBwKb/sO+CLsQQb77LNPcM455wStWrUKwo5O0kf8z/MtWd6/f/+gS5cu5scwCNn6bL9X6tQWnxbK5MmTLUZwfdStESNG2HL80qtXr+QzFKNMmTIlaNeuXdCzZ0/79OjRI5g9e3Zi7WLSlR/Idty4EYc4AEOGDAlCcW4f6n4o5M3f+L1jx44Wj0NRYs/c9OUg13rIpxyVOsX28dtvv23P0sNm2IR2auLEidY+/fbbb0Eo+MwHPKuPdf369QvmzJlj++bjE777/YnNhawvJtnsVuFXq9UlyI6RfeHtE5tvvrktCyutO+200ywrGQZfW1Zsiu0HhmnpVTCUnq5XQU+Qu3nJJtFrSQdZJa490zEgn20qShzKJtlUsjHRu6I93kcMJ6Rb733k7yT3c05qM3Ux3jDXjseokN1JJWyALAufycfZyk+248aJuJcZro1sEPU9XSzItR5ylaNSpyp87G0CTDPCNlF821VRm2fbH3KtLwbZ7CbBlwekeRliZmiU4VwCKvP9uLHkqquuynqnVWWQH8ojm8QP+VQUispM/JGPK0Y2u0nw5QkPWWbCJxOiyVoh/lq2bFmlPWn5oTyySfyQT0WhqMzEH/m4YmSzmwRfCSM/lEc2iR/yqSgUlZn4Ix9XjGx2q7Ln8AkhhBBCiNJAgk8IIYQQIuZI8AkhhBBCxBwJPiGEEEKImCPBJ4QQQggRcyT4hBBCCCFijgSfEEIIIUTMkeATQgghhIg5EnxCCCGEEDFHgk8IIYQQIuZI8AkhhBBCxBwJPiGEEEKImCPBJ4QQQggRcyT4hBBCCCFijgSfEEIIIUTMkeATQgghhIg5EnxCCCGEEDFHgk8IIYQQIuZI8AkhhBBCxBwJPiGEEEKImCPBJ4QQQggRcyT4hBBCCCFijgSfEEIIIUTMkeATQgghhIg5EnxCCCGEEDFHgk8IIYQQIuZI8AkhhBBCxBwJPiGEEEKImCPBJ4QQQggRcyT4hBBCCCFizhJBSOLvJEsssUTiLyGEEEIIUVtII+uMjIIv0w6i+pAfyiObxA/5VBSKykz8kY8rRja7aUhXCCGEECLmSPAJIYQQQsQcCT4hhBBCiJgjwSeEEEIIEXMk+IQQQgghYo4EnxBCCCFEzJHgE0IIIYSIORJ8QgghhBAxR4JPCCGEECLmSPAJIYQQQsScSr1a7YcffnDvvfee/b300ku7Fi1auHr16tl3sZg//vjD3X///W7kyJFuo402coMHD3YrrLBCYm129GqZ8sgm8UM+FYWiMhN/5OOKkc1ulcrw/fjjj+6hhx5yu+22mxs/fnxiqYiyzDLLuH322cets846NVp4v/32W3f88ce7nXbayT633HKL+/PPPxNrF68/4YQTzJfbbrutu/nmm93vv/+eWLv4Zcwvv/yya9++vW2z++672/foNeWzTV3h77//dg8//LDbdddd3c477+w6derkZsyYkVi7mHy2WbBggbvwwgttfZs2bexvlkXJ5TtRc8yaNcsdcsgh7qWXXrLvN9xwg9WP1M+UKVNsfTZ/s026fTlmruOKmuPXX391l156qX3S8d1337ljjjnGffDBB/adePnMM8+Y/4jV22yzjbvzzjuT8TrXesgnbtRF8MV1112XtNsBBxzgXn/9dVuXrX5F+fnnn93JJ5+crNOebHG4ZOpnWHjKkWFxWl588UXbnv+rgw8//DA48MADg6FDhyaWlD6//PJL0KtXL/vwd74U4odszJ07NwjFRDBw4MBg0aJFwSeffBK0bds2eOWVV8qsv/XWW4NQhARffvllEBba4Nprr7XvEFaKoHXr1sHbb79t38eNGxc0adLElnvy2aayFMsmVc2YMWOCPffc02yJDbHtjjvuGHz66aeJLXJv89tvvwVnnnlm0L9/f/PbvHnzgm7dutky1kE+vit1aotPC+Gvv/4KHn/88aBp06Zl4iN1cPDgwcGzzz5rn7FjxwZdu3YNQqGf098c48QTTwzCznVyf7YdPnx41uPGkdpSZmbOnBkcfPDBdr6XXHJJYuk/LFy4MDjppJOCFi1aJH01derUIOwE2r7U4XvvvTeoV69eMGHChLzW5xM3agNV4eNQeAWnnHKK2QHbH3fccRaDv/7666z1y4M9qWvROg254nB11s9sdiv6HL7p06e7u+++251zzjk2fLn//vu70Iju3Xffte+oWr5/8cUXtn14Du755593Xbp0sXWhM0wpe77//nvrnXTu3Nn16NHD3Xbbbbb/v/71L8uQhIXchRXK9r3++utNwQPHZzt/zPPOO88yklHofT/xxBOuT58+LhRB1gOi5xRWjKTyznYcf26sCyuUe+utt2w5cKwrr7zS1h111FHuzTffTKypfiZNmuRCoew6duxoQ++rrLKKCwu5W3vttW19WABtPb1B0sHrrruuZefCBst8QS8lDCpu6623dqGAs33oHW2yySbusccec2Hjltc2dQXKB3Vgl112MVtiU2wbBhg3ceLEvLcJhbMbPXq022+//ZJ+23vvvd2TTz7pPv74Y9sml+9EzRCKdhcGfYtJHupA2Fl1YQNvWV0+66+/vttiiy3cpptumtPfbBuK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)

### **1.2 Data Loading**
"""

"""
      1. Altered Category => Training Category
      2. Real Category => Testing Category
"""

altered_path = '/content/drive/MyDrive/BISAG Internship/Dataset/SOCOFing/Altered/Altered-' # providing path for altered category
real_path = '/content/drive/MyDrive/BISAG Internship/Dataset/SOCOFing/Real' # providing path for real category

"""
      Here data is loaded from only two categories:
      1. altered-medium | 2. altered-hard
      due to computation capacity of google colab
"""
altered_medium_data = load_data(altered_path+'Medium', train=True) # loading training data (altered-medium)
altered_hard_data = load_data(altered_path+'Hard', train=True) # loading training data (altered-hard)

real_data = load_data(real_path, train=False) # loading testing data (real)

# concatenating altered-medium and altered-hard data into one numpy array
altered_data = np.concatenate([altered_medium_data, altered_hard_data], axis=0)  

# deleting useless data
del altered_medium_data, altered_hard_data

print('Altered-Data:      ', len(altered_data)) # total number of data instances/images in altered category
print('Real-Data:          ', len(real_data)) # total number of images in real category
print('--------------------------')
print('Total Data/Images: ', len(altered_data)+len(real_data)) # total images

"""### **1.3 Input Data Format**"""

"""
      standard input format of particular person for training
        1. ID Number
        2. Finger Number
        3. Fingerprint Image in (96,96) dimension
"""
ID_number_real, finger_number_real, fingerprint_image_real = real_data[0] # accessing only first image from real data
print(ID_number_real, '\t', finger_number_real, '\n', fingerprint_image_real,'\n\n')
print('----------------------------------------------------------------------------------------\n')
ID_number_altered, finger_number_altered, fingerprint_image_altered = altered_data[0] # accessing only first image from altered data
print(ID_number_altered, '\t', finger_number_altered, '\n', fingerprint_image_altered)

"""## **2. Generating Two Datasets**

### **2.1 Preparing Training Dataset**
"""

X_altered, Y_subjectID_altered, Y_fingerNum_altered = [], [], [] # declaring three empty list 

# stroing different different values of single element into particular lists
for subjectID, fingerNum, feature in altered_data: 
  X_altered.append(feature) # feature => fingerprint image of (96,96) dimension
  Y_subjectID_altered.append(subjectID) # subjectID => ID number
  Y_fingerNum_altered.append(fingerNum) # fingerNum => fingerprint Number

X_altered = np.array(X_altered).reshape(-1, image_size, image_size, 1) # reshaping X_altered
X_altered = X_altered / 255.0 # dividing X_altered by 255.0 to make every value of intensity between 0 TO 1

"""
      Dataset 1: (X_altered, Y_subjectID_altered)
      Total 600 person: 600 categories
"""
Y_subjectID_altered = to_categorical(Y_subjectID_altered, num_classes=600) 

"""
      Dataset 2: (X_altered,Y_fingerNum_altered)
      Total 10 fingers: 10 categories
"""
Y_fingerNum_altered = to_categorical(Y_fingerNum_altered, num_classes=10)

"""
      (X_altered, Y_subjectID_altered)
      splitting dataset 1 into training and validation
      training - validation ratio: 80-20 %
"""
X_subjectID_train, X_subjectID_val, Y_subjectID_train, Y_subjectID_val = train_test_split(X_altered, Y_subjectID_altered, test_size=0.2, random_state=2)

"""
      (X_altered, Y_fingerNum_altered)
      splitting dataset 2 into training and validation
      training - validation ratio: 80-20 %
"""
X_fingerNum_train, X_fingerNum_val, Y_fingerNum_train, Y_fingerNum_val = train_test_split(X_altered, Y_fingerNum_altered, test_size=0.2, random_state=2)

"""### **2.2 Preparing Testing Dataset**"""

X_test, Y_subjectID_test, Y_fingerNum_test = [], [], [] # declaring three empty lists

for subjectID, fingerNum, feature in real_data:
  X_test.append(feature) # feature => fingerprint image of (96,96) dimension
  Y_subjectID_test.append(subjectID) # subjectID => ID number
  Y_fingerNum_test.append(fingerNum) # fingerNum => fingerprint Number

X_test = np.array(X_test).reshape(-1, image_size, image_size, 1) # reshaping X_altered
X_test = X_test / 255.0 # dividing X_altered by 255.0 to make every value of intensity between 0 TO 1

Y_subjectID_test = to_categorical(Y_subjectID_test, num_classes=600) # total 600 persons 
Y_fingerNum_test = to_categorical(Y_fingerNum_test, num_classes=10) # total 10 fingers

"""## **3. Shapes Of Datasets: SubjectID, FingerNum**"""

print("Shapes:                  Feature shape    label shape")
print("----------------------------------------------------")
print("full SubjectID data:  ", X_altered.shape, Y_subjectID_altered.shape)
print("SubjectID_Train:      ", X_subjectID_train.shape, Y_subjectID_train.shape)
print("SubjectID_Validation: ", X_subjectID_val.shape, Y_subjectID_val.shape)
print("SubjectID_Test:       ", X_test.shape, Y_subjectID_test.shape)
print("----------------------------------------------------")
print("full fingerNum data:  ", X_altered.shape, Y_fingerNum_altered.shape)
print("fingerNum_Train:      ", X_fingerNum_train.shape, Y_fingerNum_train.shape)
print("fingerNum_Validation: ", X_fingerNum_val.shape, Y_fingerNum_val.shape)
print("fingerNum_Test:       ", X_test.shape, Y_fingerNum_test.shape)

del altered_data, real_data, Y_subjectID_altered # removing useless datasets

"""## **4. Convolutional Neural Networks**

### **4.1 Building Models**
"""

nets = 2
model = [0] * nets

"""
      first unit is for first subjectID model: 600
      second unit is for second fingerNum model: 10
"""
final_Dense_units = [600,10]

"""
      there are two different models:
      1. subjectID model for subjectID dataset
      2. fingerNum model for fingerNum dataset
"""
model_name = ['SubjectID_Mod','FingerNum_Mod']

# building two same models
for i in range(nets):
  model[i] = Sequential(name=model_name[i]) # giving name to particular sequential model
  model[i].add(layers.Conv2D(32, (5,5), activation='relu', kernel_regularizer=regularizers.l2(0.001),input_shape=(96,96,1)))
  model[i].add(layers.BatchNormalization())
  model[i].add(layers.MaxPool2D((2,2)))
  model[i].add(layers.Conv2D(64, (5,5), activation='relu', kernel_regularizer=regularizers.l2(0.001)))
  model[i].add(layers.BatchNormalization())
  model[i].add(layers.MaxPool2D((2,2)))
  model[i].add(layers.Conv2D(128, (3,3), activation='relu', kernel_regularizer=regularizers.l2(0.001)))
  model[i].add(layers.BatchNormalization())
  model[i].add(layers.MaxPool2D((2,2)))
  model[i].add(layers.Dropout(0.3))
  model[i].add(layers.Flatten())
  model[i].add(layers.Dense(256, activation='relu'))
  model[i].add(layers.Dropout(0.4))
  model[i].add(layers.Dense(final_Dense_units[i], activation='softmax'))
  
  # Compliling models with Adam optimizer and entropy cost 
  model[i].compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])

"""### **4.2 Model Summary**"""

for j in range(2):
  model[j].summary()

"""### **4.3 Models Architecture**"""

# plotting ID model graph in layers
plot_model(model[0], show_shapes=True, to_file='/content/drive/MyDrive/BISAG Internship/Models/model0.png')

# plotting finger model graph in layers
plot_model(model[1], show_shapes=True, to_file='/content/drive/MyDrive/BISAG Internship/Models/model1.png')

"""### **4.4 Deleting fingerNum Dataset Temporarily Due To The Overloading Problem**"""

del X_fingerNum_train, X_fingerNum_val, Y_fingerNum_train, Y_fingerNum_val

"""### **4.5 Fitting Models**

#### **4.5.1 Model Callbacks**
"""

"""
      model[0]: subjectID model
      model[1]: fingerNum model
"""

history = [0]*nets # history list for two models
CallBack = [0]*nets # callback list for two models
ReduceLR_minlr = [1e-9, 1e-7] # lowerbound of learning rate for both models
epochs = 20 # number of epochs
batch_size = 64 # batch size

# declaring callbacks for both subjectID and fingerNum models
for i in range(nets):
  CallBack[i] = [callbacks.EarlyStopping(monitor='val_accuracy', patience=10, mode='max', verbose=1),
                 callbacks.ReduceLROnPlateau(factor=0.1, patience=1, min_lr=ReduceLR_minlr[i], verbose=1),
                 callbacks.TensorBoard(log_dir='/content/drive/MyDrive/BISAG Internship/Models/log_dir/'+model_name[i])]

"""#### **4.5.2 Fitting To SubjectID Model**"""

# fitting data to model[0]: subjectID model with callbacks
history[0] = model[0].fit(X_subjectID_train, Y_subjectID_train, batch_size=batch_size, epochs=epochs, validation_data = (X_subjectID_val,Y_subjectID_val), verbose=1, callbacks=CallBack[0])

# saving subjectID model at given path in h5 format
model[0].save('/content/drive/MyDrive/BISAG Internship/Models/Fingerprint_Matching/2_FM_Model_0.h5')

"""#### **4.5.3 Fitting To FingerNum Model**"""

# deleting subjectID dataset to overcome overloading problem
del X_subjectID_train, X_subjectID_val, Y_subjectID_train, Y_subjectID_val

# Reloading fingerNum dataset before model fitting
X_fingerNum_train, X_fingerNum_val, Y_fingerNum_train, Y_fingerNum_val = train_test_split(X_altered, Y_fingerNum_altered, test_size=0.2, random_state=2)

# deleting useless X_altered and Y_fingerNum_altered dataset
del X_altered, Y_fingerNum_altered

# fitting data to model[1]: fingerNum model with callbacks
history[1] = model[1].fit(X_fingerNum_train, Y_fingerNum_train, batch_size=batch_size, epochs=epochs, validation_data=(X_fingerNum_val, Y_fingerNum_val), verbose=1, callbacks=CallBack[1])

# saving fingerNum model at given path in h5 format
model[1].save('/content/drive/MyDrive/BISAG Internship/Models/Fingerprint_Matching/2_FM_Model_1.h5')

"""### **4.6 Adjusting Hyperparameters Via Tensorboard**"""

# Commented out IPython magic to ensure Python compatibility.
# loading tensorboard for subjectID model
# %load_ext tensorboard

# importing subjectID model's log from given path 
# %tensorboard --logdir '/content/drive/MyDrive/BISAG Internship/Models/log_dir/SubjectID_Mod'

# Commented out IPython magic to ensure Python compatibility.
# loading tensorboard for fingerNum model
# %load_ext tensorboard

# importing fingerNum model's log from given path 
# %tensorboard --logdir '/content/drive/MyDrive/BISAG Internship/Models/log_dir/FingerNum_Mod'

"""## **5. Loading Models**"""

def load_model():
  model = [0,1] # declaring list for models
  model[0] = tf.keras.models.load_model('/content/drive/MyDrive/2_FM_Model_0.h5') # loading subjectID model
  model[1] = tf.keras.models.load_model('/content/drive/MyDrive/2_FM_Model_1.h5') # loading fingerNum model

"""## **6. Visualizing Training and Validation Processess With Accuracy and Loss**"""

accuracy = [0]*nets # declaring training accuracy list
validation_accuracy = [0]*nets # validation accuracy list
loss = [0]*nets # training loss list
validation_loss = [0]*nets # validation loss list

for i in range(nets):
  accuracy[i] = history[i].history['accuracy'] # storing accuracy history with epochs for particular model
  validation_accuracy[i] = history[i].history['val_accuracy'] # storing validation accuracy history 
  loss[i] = history[i].history['loss'] # storing loss history
  validation_loss[i] = history[i].history['val_loss'] # storing validation loss history

  epochs = range(1, len(accuracy[i]) + 1) # declaring total number of epochs
  
  """
        plotting graph for training and vaildation accuracy
        graph: accuracy vs. epochs
  """
  plt.figure()
  plt.plot(epochs, accuracy[i], label='Training accuracy of '+ model_name[i])
  plt.plot(epochs, validation_accuracy[i], label='Validation accuracy of '+ model_name[i])
  plt.title('Training and Validation accuracy of '+ model_name[i])
  plt.legend()

  """
        plotting graph for training and vaildation loss
        graph: loss vs. epochs
  """
  plt.figure()
  plt.plot(epochs, loss[i], label='Training loss of '+ model_name[i])
  plt.plot(epochs, validation_loss[i], label='Validation loss of '+model_name[i])
  plt.title('Training and validation loss of '+model_name[i])
  plt.legend()

# model[0]: subjectID model evaluation based on testing dataset
testing_accuracy_id = model[0].evaluate([X_test],[Y_subjectID_test],verbose=0)
print('ID Recognition accuracy:     ',testing_accuracy_id[1]*100, '%')

# model[1]: fingerNum model evaluation based on testing dataset
testing_accuracy_finger = model[1].evaluate([X_test],[Y_fingerNum_test], verbose=0)
print('Finger Recognition Accuracy: ', testing_accuracy_finger[1]*100, '%')

"""## **7. Visualizing Predictions Of FingerNum Model**"""

# visualize finger number prediciton with confusion matrix
def plot_confusion_matrix(conmat, classes, normalize=True, title='Confusion Matrix',cmap=plt.cm.Blues):
  """
  This function prints and plots the confusion matrix.
  Normalization can be applied by setting `normalize=True`.
  """

  plt.figure(figsize=(15,10)) # setting figure size
  plt.imshow(conmat, interpolation='nearest', cmap=cmap) # printing confusion matrix on output kernel
  plt.title(title) # setting title 'Confusion Matrix'
  plt.colorbar() # setting colorbar
  tick_marks = np.arange(len(classes)) # setting labels of classes: 0-9 (10 classes)
  plt.xticks(tick_marks, classes) # setting classes labels on x-axis
  plt.yticks(tick_marks, classes) # setting classes labels on y-axis

  # normalize=True to see prediction probability for every classes
  if normalize:
    conmat = np.round(conmat.astype('float') / conmat.sum(axis=1)[:,np.newaxis], decimals=6)

  thresh = conmat.max()/2
  for i, j in itertools.product(range(conmat.shape[0]), range(conmat.shape[1])):
      plt.text(j, i, conmat[i,j], horizontalalignment='center', color='white' if conmat[i,j] > thresh else 'black')

  plt.tight_layout() # setting layout
  plt.ylabel('real label') # setting y-axis label
  plt.xlabel('predicted label') # setting x-axis label
  plt.savefig('/content/drive/MyDrive/BISAG Internship/Models/Fingerprint_Matching/ConfusionMatrix_Proba.png') # saving confusion matrix at particular path

Y_fingerNum_prediction = model[1].predict(X_test) # predicting values on X_test using fingerNum model


"""
      here prediction of each and every sample contains 10 elements
      which shows the probability of of each and every class for input
      sample. That is why it is required to apply argmax on predcition array
      with axis = 1.
      Like:
          [0.99, 0.0002, 0.005, 0.000, 0.001, 0.000637, 0.00000003, 0.000009, 0.000027, 0.004]
          so argmax is applied on this list it will return index of max value.
          Output: 0 (index)
"""
Y_fingerNum_prediction_classes = np.argmax(Y_fingerNum_prediction, axis=1)

# similar process for Y_fingerNum_real as mentioned above
Y_fingerNum_real = np.argmax(Y_fingerNum_test, axis=1)

# generating confusion matrix based on Y_fingerNum_real and Y_fingerNum_prediction
confusion_mtx = confusion_matrix(Y_fingerNum_real, Y_fingerNum_prediction_classes)

# calling plot_confusion_matrix() function
plot_confusion_matrix(confusion_mtx, classes=range(10))

# printing confusion matrix
confusion_mtx

"""## **8. Single Sample Testing**




"""

# show_fingername() function returns fingername based on finger number

def show_fingername(fingernum):

    if fingernum>=5:
        fingername = "right "
        fingernum -= 5
    else: fingername = "left "

    if fingernum==0:
        fingername += "little"
    elif fingernum==1:
        fingername += "ring"
    elif fingernum==2:
        fingername += "middle"
    elif fingernum==3:
        fingername += "index"
    else: fingername += "thumb"
    
    return fingername

# test_single_sample() function is used for single image prediction
def test_single_sample(path):

  model = [0,1] # declaring list for models
  model[0] = tf.keras.models.load_model('/content/drive/MyDrive/BISAG Internship/Models/Fingerprint_Matching/2_FM_Model_0.h5') # loading subjectID model
  model[1] = tf.keras.models.load_model('/content/drive/MyDrive/BISAG Internship/Models/Fingerprint_Matching/2_FM_Model_1.h5') # loading fingerNum model

  input_image = cv2.imread(path, cv2.IMREAD_GRAYSCALE) # reading image

  resized_image = cv2.resize(input_image, (96,96)) # resizing image into (96,96) dimension
  resized_image = np.array(resized_image).reshape(-1,96,96,1) # reshaping image


  """
        dividing each and every pixel value by 255.0 
        to get each and every value between 0 TO 1
  """
  resized_image = resized_image / 255.0 

  pred_prob_array_0 = model[0].predict(resized_image) # subjectID model prediction
  pred_prob_array_1 = model[1].predict(resized_image) # fingerNum model prediction

  pred_prob_list_0 = pred_prob_array_0.tolist() # converting predicted array into list
  pred_prob_list_1 = pred_prob_array_1.tolist() # converting predicted array into list

  pred_prob_list_0 = pred_prob_list_0[0] # getting first list of class wise probability 
  pred_prob_list_1 = pred_prob_list_1[0] # getting first list of class wise probability 
  
  max_prob_0 = max(pred_prob_list_0) # finding max probability for particular class from list
  max_prob_1 = max(pred_prob_list_1) # finding max probability for particular class from list

  """
         if max probability of subjectID number for particular class is 
         greater than 0.9100 then and then allows system to show 
         finger name and id number. Otherwise show "user does not exist".
  """
  if max_prob_0 >= 0.9100: 

    finger_number = (pred_prob_list_1.index(max_prob_1)) # getting fingernumber
    finger_name = show_fingername(finger_number) # getting fingername

    ID_number = (pred_prob_list_0.index(max_prob_0)+1) # getting id number

    state = 'Fingerprint Matched' # setting state

  else:

    finger_number = (pred_prob_list_1.index(max_prob_1)+1) # getting fingernumber
    finger_name = show_fingername(finger_number) # getting fingername

    ID_number = 0000 # setting id number to zero due to low probability

    state = 'User Does Not Exist' # setting state

  return state, finger_name, ID_number

# calling test_single_sample() function
matching_state, fname, ID = test_single_sample('/content/drive/MyDrive/429__M_Right_little_finger_Obl.BMP')

# printing result
print(matching_state,'|',fname,'|',ID)